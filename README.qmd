---
format: gfm
knitr:
  opts_chunk:
    collapse: true
    comment: "#>"
    fig-align: center
    fig-path: "man/figures/README-"
    fig-format: svg
---

<!-- README.md is generated from README.qmd. Please edit that file -->

# extera

<!-- badges: start -->
[![R-CMD-check](https://github.com/kbvernon/extera/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/kbvernon/extera/actions/workflows/R-CMD-check.yaml)
[![CRAN status](https://www.r-pkg.org/badges/version/extera)](https://CRAN.R-project.org/package=extera)
[![extendr](https://img.shields.io/badge/extendr-^0.8.0-276DC2)](https://extendr.github.io/extendr/extendr_api/)
<!-- badges: end -->

The name `extera` is a portmanteau of `extendr` and `tera`, making it suggestive
of the package's intended purpose, which is to provide an 
[`extendr`](https://github.com/extendr/extendr)-powered R wrapper around the 
blazing fast [`tera`](https://github.com/Keats/tera) templating-engine in Rust.

## Installation

You can install the development version of `extera` like so:

``` r
# install.packages("pak")
pak::pak("kbvernon/extera")
```

## Usage

To get a feel for what `extera` can do, let's start with a simple "hello world"
example.

```{r}
#| label: hello-world
library(extera)

tera <- ExTera$new()

tera$add_string_templates(
  "hello-world" = '<p>Hello {{ x }}. This is {{ y }}.</p>'
)

tera

tera$render_to_string(
  "hello-world",
  x = "world",
  y = "ExTera"
)
```

The syntax and API should look pretty familiar to anyone who has used `glue` to
do something like `glue::glue("Foo { x }", x = "bar")`. The big difference is
the object-oriented workflow.

## Initializing `ExTera`

Everything in `extera` revolves around the `ExTera` object, which serves as a 
template library with encapsulated rendering methods. In the above example, we 
initialize an `ExTera` with an empty template library by calling `ExTera$new()` 
with no arguments.

If you have a complicated directory system with nested templates and inheritance 
patterns - a common situation for web development, you may find it easier to 
initialize an `ExTera` by specifying the directory with a glob containing the 
`*` wildcard to indicate any number of subfolders and template files. Suppose, 
for example, that you have a `website` directory that looks like this: 

```{r collapse = FALSE, comment = ""}
#| label: directory
#| code-fold: true
website <- file.path(tempdir(), "website")

dir.create(website)
dir.create(file.path(website, "posts"))

writeLines(
  text = '<p>Hello {{ x }}. This is {{ y }}.</p>',
  con = file.path(website, "index.html")
)

writeLines(
  text = "<h2>About Me</h2><p>{{ description }}</p>",
  con = file.path(website, "about-me.html")
)

writeLines(
  text = '<body>
  <h2>{{ title }}</h2>
  <p>{{ paragraph }}</p>
</body>
',
  con = file.path(website, "posts", "blog-template.html")
)

cat(
  "website",
  list.files(website, recursive = TRUE),
  sep = "\n- "
)
```

You can generate a new `ExTera` around this directory like so

```{r}
#| label: glob
tera <- ExTera$new(dir = file.path(website, "**/*.html"))

tera
```

## Rendering basics

To render a template, you have to supply a `context`, or a set of key-value 
pairs, with the keys being the variable names - surrounded by `{{{ variable }}}`
in the template - and their values being the content to inject into the 
template. You can render a template in one of two ways, using 

- `self$render()` to render to a file on disk or
- `self$render_to_string()` to render to a character string in the current R 
session.  

Consider our hypothetical website's blog post template:

```{r collapse = FALSE, comment = ""}
#| label: blog-template
#| code-fold: true
file.path(website, "posts", "blog-template.html") |>
  readLines() |>
  cat(sep = "\n")
```

Here are the two ways to render this template.

```{r}
#| label: render
# render to file
outfile <- file.path(tempdir(), "rendered-blog-post.html")

tera$render(
  "posts/blog-template.html",
  outfile = outfile,
  title = "This is my blog",
  paragraph = "Democracy was fun, wasn't it?"
)

cat(
  readLines(outfile, warn = FALSE),
  sep = "\n"
)

# render to string
tera$render_to_string(
  "posts/blog-template.html",
  title = "This is my blog",
  paragraph = "Democracy was fun, wasn't it?"
)
```

Did you notice that the apostrophe was converted into the html character entity
`&#x27;`? This is an example of escaping, which `tera` does by default. You can
turn off this behavior using `self$autoescape_off()`.

```{r}
#| label: autoescape
tera$autoescape_off()

tera$render_to_string(
  "posts/blog-template.html",
  title = "This is my blog",
  paragraph = "Democracy was fun, wasn't it?"
)
```

And then turn it back on with `self$autoescape_on()`.

## Rendering logic

The `tera` templating engine offers a lot of additional functionality, like 
control flow and data manipulation. The following example shows how to construct
a for-loop, add conditional statements, and apply built-in functions. Notice 
that `{% expression %}` is used to signal these expressions in the template. The 
use of dashes tells the renderer to remove white space before 
(`{%- expression %}`) or after (`{% expression -%}`) the expression.

```{r}
#| label: render-logic
tera$add_string_templates(
  "star-wars" = '<h2>{{ title }}</h2>
<ol>
{%- for person in people %}
  {%- if person.films is containing("A New Hope") %}
  {%- if person.species and person.species is containing("Human") %}
  <li>{{ person.name }} ({{ person.homeworld }})</li>
  {%- endif %}
  {%- endif %}
{%- endfor %}
</ol>
'
)

starwars <- dplyr::starwars[c("name", "films", "homeworld", "species")]

tera$render_to_string(
  "star-wars",
  title = "Humans of A New Hope",
  people = starwars
)
```

## Context format

In that for-loop, you may have noticed that we used dot-indexing syntax, e.g., 
`person.name`. If `person` was a list in R, this would be equivalent to 
`person[["name"]]`. This usage suggests that the context should have a specific 
format, like a named list. In fact, the `tera` templating engine generally 
expects data to be in, let's say, a JSON-like format. The biggest way this 
affects data structures coming from R is in the way that data.frames are 
handled. In R, tables are column-major, but the JSON-like format that `tera` 
wants is row-major or "record" oriented.

The way `extera` handles this is by serializing all R data structures added to
the context as JSON using `yyjsonr`. This is not ideal, but it is relatively 
safe. It also enforces a specific data model that users should be able to 
reason about fairly well. Oh, and `yyjsonr` is very, very fast, so performance 
issues are minor.

It may help to see an example of what that looks like. This applies the same 
filters we used in our template above.

```{r}
#| label: yyjsonr
starwars[["in_a_new_hope"]] <- sapply(
  starwars[["films"]],
  \(x) "A New Hope" %in% x
)

starwars <- subset(
  starwars,
  in_a_new_hope & !is.na(species) & species == "Human",
  select = c(name, homeworld)
)

json_str <- yyjsonr::write_json_str(
  list(
    title = "Humans of A New Hope",
    people = starwars
  ),
  pretty = TRUE
)

cat(json_str)
```

## Inheritance

Templates can inherit content from each other in one of two ways, either using
`include` or, for more complicated inheritance, `extends`.

```{r}
#| label: include
tera$add_string_templates(
  "index.html" = '<p>Hello {{ x }}. This is {{ y }}.</p>
<div>
{% include "posts/blog-template.html" -%}
</div>
'
)

tera$render_to_string(
  "index.html",
  x = "world",
  y = "ExTera",
  title = "My blog post",
  paragraph = "The Book of Bokonon tells us..."
)
```

The extension mechanism is a little more involved, requiring that you specify
content blocks where content from a child document should be injected. In the
following example, we define a single block called `content` in the base or 
parent template and specify what it includes in the child template.

```{r}
#| label: extends
base_html <- '<body>
  <div id="content">
    {% block content %}
    {% endblock content %}
  </div>
</body>
'

child_html <- '{% extends "base.html" %}
{%- block content %}
  <h1>{{ title }}</h1>
  <p>{{ paragraph }}</p>
{% endblock content -%}
'

tera$add_string_templates(
  "base.html" = base_html,
  "child.html" = child_html
)

tera$render_to_string(
  "child.html",
  title = "Index",
  paragraph = "Welcome to my homepage."
)
```

For more details, check out the 
[documentation](https://keats.github.io/tera/docs/) for `tera`.